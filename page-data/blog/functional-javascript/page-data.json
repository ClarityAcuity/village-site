{"componentChunkName":"component---src-components-md-posts-layout-js","path":"/blog/functional-javascript/","result":{"data":{"mdx":{"id":"c88f62a1-2c7b-5148-a9c3-205bb019bf63","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"FUNCTIONAL JAVASCRIPT\",\n  \"date\": \"2021-04-14\",\n  \"updated\": \"2021-04-14\",\n  \"author\": \"Villager Liao\",\n  \"keywords\": [\"functional programing\", \"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Functional Javascript\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Curried function\")), mdx(\"p\", null, \"A curried function is a function which takes multiple parameters one at a time, by taking the first argument, and returning a series of functions which each take the next argument until all the parameters have been fixed, and the function application can complete, at which point, the resulting value is returned.\"), mdx(\"p\", null, \"Curried functions are great for function composition, because they allow you to easily convert an n-ary function into the unary function form needed for function composition pipelines: Functions in a pipeline must expect exactly one argument.\\nData last functions are convenient for function composition, because they can be easily used in point-free style.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// add = a => b => Number\\nconst add = a => b => a + b;\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Partial application\")), mdx(\"p\", null, \"A partial application is a function which has been applied to some, but not yet all of its arguments. The arguments which the function has already been applied to are called fixed parameters.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Point-free\")), mdx(\"p\", null, \"Point-free style is a style of programming where function definitions do not make reference to the function\\u2019s arguments. Generally, a point-free function is created by calling a function which returns a function, such as a curried function.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// inc = n => Number\\n// Adds 1 to any number.\\nconst inc = add(1);\\ninc(3); // => 4\\n\\nconst inc10 = add(10);\\nconst inc20 = add(20);\\ninc10(3); // => 13\\ninc20(3); // => 23\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Compose\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"/* Algebra definition, borrowing the `.` composition operator from Haskell\\nh: a -> c\\nh = f . g = f(g(x))\\n*/\\nconst g = n => n + 1;\\nconst f = n => n * 2;\\nconst h = x => f(g(x));\\nh(20); //=> 42\\n\\nconst compose = (f, g) => x => f(g(x));\\n\\nconst compose = (...fns) => x => fns.reduceRight((y, f) => f(y), x);\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pipe\")), mdx(\"p\", null, \"There's another composition utility called pipe() that composes in reverse order:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Trace\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\\nconst trace = label => value => {\\n  console.log(`${ label }: ${ value }`);\\n  return value;\\n};\\nconst g = n => n + 1;\\nconst f = n => n * 2;\\n/*\\nNow the function application order\\nruns top-to-bottom:\\n*/\\nconst h = pipe(\\n  g,\\n  trace('after g'),\\n  f,\\n  trace('after f'),\\n);\\nh(20);\\n/*\\nafter g: 21\\nafter f: 42\\n*/\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Together\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const map = fn => mappable => mappable.map(fn);\\nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\\nconst log = (...args) => console.log(...args);\\nconst arr = [1, 2, 3, 4];\\nconst isEven = n => n % 2 === 0;\\nconst stripe = n => isEven(n) ? 'dark' : 'light';\\nconst stripeAll = map(stripe);\\nconst striped = stripeAll(arr); \\nlog(striped);\\n// => [\\\"light\\\", \\\"dark\\\", \\\"light\\\", \\\"dark\\\"]\\nconst double = n => n * 2;\\nconst doubleAll = map(double);\\nconst doubled = doubleAll(arr);\\nlog(doubled);\\n// => [2, 4, 6, 8]\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Flip\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const flip = fn => a => b => fn(b)(a);\\n\\nconst pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);\\nconst trace = value => label => {\\n  console.log(`${ label }: ${ value }`);\\n  return value;\\n};\\nconst flippedTrace = flip(trace);\\nconst g = n => n + 1;\\nconst f = n => n * 2;\\nconst h = pipe(\\n  g,\\n  flippedTrace('after g'),\\n  f,\\n  flippedTrace('after f'),\\n);\\nh(20);\\n\")), mdx(\"p\", null, \"But a better approach is to write the function correctly in the first place. The style is sometimes called \\u201Cdata last\\u201D, which means that you should take the specializing parameters first, and take the data the function will act on last.\"), mdx(\"p\", null, \"Data last functions are convenient for function composition, because they can be easily used in point-free style.\"), mdx(\"h2\", null, \"Ref:\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"https://medium.com/javascript-scene/curry-and-function-composition-2c208d774983\"\n  }, \"Curry and Function Composition\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"FUNCTIONAL JAVASCRIPT","date":"2021-04-14","author":"Villager Liao","keywords":["functional programing","javascript"]},"slug":"functional-javascript/","excerpt":"Functional Javascript Curried function A curried function is a function which takes multiple parameters one at a time, by taking the firstâ€¦"}},"pageContext":{"id":"c88f62a1-2c7b-5148-a9c3-205bb019bf63","slug":"functional-javascript/"}},"staticQueryHashes":["1059609371","2459496995"]}