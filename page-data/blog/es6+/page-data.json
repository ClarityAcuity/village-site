{"componentChunkName":"component---src-components-md-posts-layout-js","path":"/blog/es6+/","result":{"data":{"mdx":{"id":"9712ccf1-ab09-5d8c-bb2d-a3dc885b2fcb","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"ES6+\",\n  \"date\": \"2021-05-02\",\n  \"updated\": \"2021-05-02\",\n  \"author\": \"Villager Liao\",\n  \"keywords\": [\"javascript\", \"es6\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Es6+\"), mdx(\"h2\", null, \"Arrow Function\"), mdx(\"p\", null, \"diffence\"), mdx(\"p\", null, \"Differences & Limitations:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Does not have its own bindings to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"this\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"super\"), \", and should not be used as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"methods\"), \".\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"'use strict';\\n\\nvar obj = { // does not create a new scope\\n  i: 10,\\n  b: () => console.log(this.i, this),\\n  c: function() {\\n    console.log(this.i, this);\\n  }\\n}\\n\\nobj.b(); // prints undefined, Window {...} (or the global object)\\nobj.c(); // prints 10, Object {...}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"'use strict';\\n\\nvar obj = {\\n  a: 10\\n};\\n\\nObject.defineProperty(obj, 'b', {\\n  get: () => {\\n    console.log(this.a, typeof this.a, this); // undefined 'undefined' Window {...} (or the global object)\\n    return this.a + 10; // represents global object 'Window', therefore 'this.a' returns 'undefined'\\n  }\\n});\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Does not have \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"arguments\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"new.target\"), \" keywords. They have access to the arguments object of the closest non-arrow parent function.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var arguments = [1, 2, 3];\\nvar arr = () => arguments[0];\\n\\narr(); // 1\\n\\nfunction foo(n) {\\n  var f = () => arguments[0] + n; // foo's implicit arguments binding. arguments[0] is n\\n  return f();\\n}\\n\\nfoo(3); // 3 + 3 = 6\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The value of this inside an arrow function remains the same throughout the lifecycle of the function and is always bound to the value of this in the closest non-arrow parent function.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Not suitable for call, apply and bind methods, which generally rely on establishing a scope.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// A simplistic object with its very own \\\"this\\\".\\nvar obj = {\\n    num: 100\\n}\\n\\n// Setting \\\"num\\\" on window to show how it is NOT used.\\nwindow.num = 2020; // yikes!\\n\\n// A simple traditional function to operate on \\\"this\\\"\\nvar add = function (a, b, c) {\\n  return this.num + a + b + c;\\n}\\n\\n// Arrow Function\\nvar arrowAdd = (a, b, c) => this.num + a + b + c;\\n\\n// call\\nvar result = add.call(obj, 1, 2, 3) // establishing the scope as \\\"obj\\\"\\nconsole.log(result) // result 106\\nconsole.log(arrowAdd.call(obj, 1, 2, 3)) // result 2026\\n\\n\\n// apply\\nconst arr = [1, 2, 3]\\nvar result = add.apply(obj, arr) // establishing the scope as \\\"obj\\\"\\nconsole.log(result) // result 106\\nconsole.log(arrowAdd.apply(obj, arr)) // result 2026\\n\\n\\n// bind\\nvar result = add.bind(obj) // establishing the scope as \\\"obj\\\"\\nconst bound = arrowAdd.bind(obj)\\nconsole.log(result(1, 2, 3)) // result 106\\nconsole.log(bound(1, 2, 3)) // result 2026\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Can not be used as constructors.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var Foo = () => {};\\nvar foo = new Foo(); // TypeError: Foo is not a constructor\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Does not have a prototype property.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var Foo = () => {};\\nconsole.log(Foo.prototype); // undefined\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Can not use yield, within its body. As a consequence, arrow functions cannot be used as generators.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Arrow functions can never have duplicate named parameters.\"))), mdx(\"h2\", null, \"Promise\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Promise callbacks are handled as a Microtask\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".resolve(value)\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".reject(reason)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".then()\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".catch()\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".finally()\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let isLoading = true;\\n\\nfetch(myRequest).then(function(response) {\\n    var contentType = response.headers.get(\\\"content-type\\\");\\n    if(contentType && contentType.includes(\\\"application/json\\\")) {\\n      return response.json();\\n    }\\n    throw new TypeError(\\\"Oops, we haven't got JSON!\\\");\\n  })\\n  .then(function(json) { /* process your JSON further */ })\\n  .catch(function(error) { console.error(error); /* this line can also throw, e.g. when console = {} */ })\\n  .finally(function() { isLoading = false; });\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".all(iterable)\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// from mdn\\nconst applyAsync = (acc,val) => acc.then(val);\\nconst composeAsync = (...funcs) => x => funcs.reduce(applyAsync, Promise.resolve(x));\\nconst transformData = composeAsync(func1, func2, func3);\\nconst result3 = transformData(data);\\n\\n// or\\nlet result;\\nfor (const f of [func1, func2, func3]) {\\n  result = await f(result);\\n}\\n/* use last result (i.e. result3) */\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".allSettled(iterable)\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".any(iterable)\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \".race()\"))), mdx(\"h2\", null, \"Async Function\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"async function foo() {\\n   return 1\\n}\\n// it will be implicitly wrapped in a promise\\nfunction foo() {\\n   return Promise.resolve(1)\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function resolveAfter2Seconds() {\\n  console.log(\\\"starting slow promise\\\")\\n  return new Promise(resolve => {\\n    setTimeout(function() {\\n      resolve(\\\"slow\\\")\\n      console.log(\\\"slow promise is done\\\")\\n    }, 2000)\\n  })\\n}\\n\\nfunction resolveAfter1Second() {\\n  console.log(\\\"starting fast promise\\\")\\n  return new Promise(resolve => {\\n    setTimeout(function() {\\n      resolve(\\\"fast\\\")\\n      console.log(\\\"fast promise is done\\\")\\n    }, 1000)\\n  })\\n}\\n\\nasync function sequentialStart() {\\n  console.log('==SEQUENTIAL START==')\\n\\n  // 1. Execution gets here almost instantly\\n  const slow = await resolveAfter2Seconds()\\n  console.log(slow) // 2. this runs 2 seconds after 1.\\n\\n  const fast = await resolveAfter1Second()\\n  console.log(fast) // 3. this runs 3 seconds after 1.\\n}\\n\\nasync function concurrentStart() {\\n  console.log('==CONCURRENT START with await==');\\n  const slow = resolveAfter2Seconds() // starts timer immediately\\n  const fast = resolveAfter1Second() // starts timer immediately\\n\\n  // 1. Execution gets here almost instantly\\n  console.log(await slow) // 2. this runs 2 seconds after 1.\\n  console.log(await fast) // 3. this runs 2 seconds after 1., immediately after 2., since fast is already resolved\\n}\\n\\nfunction concurrentPromise() {\\n  console.log('==CONCURRENT START with Promise.all==')\\n  return Promise.all([resolveAfter2Seconds(), resolveAfter1Second()]).then((messages) => {\\n    console.log(messages[0]) // slow\\n    console.log(messages[1]) // fast\\n  })\\n}\\n\\nasync function parallel() {\\n  console.log('==PARALLEL with await Promise.all==')\\n\\n  // Start 2 \\\"jobs\\\" in parallel and wait for both of them to complete\\n  await Promise.all([\\n      (async()=>console.log(await resolveAfter2Seconds()))(),\\n      (async()=>console.log(await resolveAfter1Second()))()\\n  ])\\n}\\n\\nsequentialStart() // after 2 seconds, logs \\\"slow\\\", then after 1 more second, \\\"fast\\\"\\n\\n// wait above to finish\\nsetTimeout(concurrentStart, 4000) // after 2 seconds, logs \\\"slow\\\" and then \\\"fast\\\"\\n\\n// wait again\\nsetTimeout(concurrentPromise, 7000) // same as concurrentStart\\n\\n// wait again\\nsetTimeout(parallel, 10000) // truly parallel: after 1 second, logs \\\"fast\\\", then after 1 more second, \\\"slow\\\"\\n\")), mdx(\"h2\", null, \"Generator\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Generator\"), \" object is returned by a generator function and it conforms to both the iterable protocol and the iterator protocol.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function* generator() {\\n  yield 1;\\n  yield 2;\\n  yield 3;\\n}\\n\\nconst gen = generator(); // \\\"Generator { }\\\"\\n\\nconsole.log(gen.next().value); // 1\\nconsole.log(generator().next().value); // 1\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".next()\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".return()\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".throw()\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Calling a generator function does not execute its body immediately; an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iterator\"), \" object for the function is returned instead.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"When the iterator's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next()\"), \" method is called, the generator function's body is executed until the first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" expression.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"next()\"), \" method returns an object with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" property containing the yielded value and a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"done\"), \" property which indicates whether the generator has yielded its last value, as a boolean.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \" statement in a generator, when executed, will make the generator finish.\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function* yieldAndReturn() {\\n  yield \\\"Y\\\";\\n  return \\\"R\\\";\\n  yield \\\"unreachable\\\";\\n}\\n\\nvar gen = yieldAndReturn()\\nconsole.log(gen.next()); // { value: \\\"Y\\\", done: false }\\nconsole.log(gen.next()); // { value: \\\"R\\\", done: true }\\nconsole.log(gen.next()); // { value: undefined, done: true }\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"error\"), \" thrown inside the generator will make the generator finished -- unless caught within the generator's body.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When a generator is finished, subsequent \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"next()\"), \" calls will not execute any of that generator's code, they will just return an object of this form: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"{ value: undefined, done: true }\"), \".\")), mdx(\"h2\", null, \"Reflect\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\"\n  }, \"Reflect is a built-in object that provides methods for interceptable JavaScript operations.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"ES6+","date":"2021-05-02","author":"Villager Liao","keywords":["javascript","es6"]},"slug":"es6+/","excerpt":"ES6+ Arrow Function diffence Differences & Limitations: Does not have its own bindings to  this  or  super , and should not be used as…"}},"pageContext":{"id":"9712ccf1-ab09-5d8c-bb2d-a3dc885b2fcb","slug":"es6+/"}},"staticQueryHashes":["1059609371","2459496995"]}