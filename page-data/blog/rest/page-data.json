{"componentChunkName":"component---src-components-md-posts-layout-js","path":"/blog/rest","result":{"data":{"mdx":{"id":"6cee691f-48c3-597c-bfd3-9fd7e19ce900","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"RESTful API\",\n  \"date\": \"2021-04-08\",\n  \"author\": \"Villager Liao\",\n  \"keywords\": [\"architecture\", \"rest\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Representational State Transfer\"), mdx(\"p\", null, \"The REST architectural style describes six constraints. These constraints, applied to the architecture, were originally communicated by Roy Fielding in his \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm\"\n  }, \"doctoral dissertation\"), \" and defines the basis of RESTful-style.\"), mdx(\"h2\", null, \"Uniform Interface\"), mdx(\"p\", null, \"The uniform interface constraint defines the interface between clients and servers. It simplifies and decouples the architecture, which enables each part to evolve independently.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Resource-Based\")), mdx(\"p\", null, \"Individual resources are identified in requests using URIs as resource identifiers. The resources themselves are conceptually separate from the representations that are returned to the client. For example, the server does not send its database, but rather, some HTML, XML or JSON that represents some database records expressed, for instance, in Finnish and encoded in UTF-8, depending on the details of the request and the server implementation.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Manipulation of Resources Through Representations\")), mdx(\"p\", null, \"When a client holds a representation of a resource, including any metadata attached, it has enough information to modify or delete the resource on the server, provided it has permission to do so.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Self-descriptive Messages\")), mdx(\"p\", null, \"Each message includes enough information to describe how to process the message. For example, which parser to invoke may be specified by an Internet media type (previously known as a MIME type). Responses also explicitly indicate their cache-ability.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Hypermedia as the Engine of Application State (HATEOAS)\")), mdx(\"p\", null, \"Clients deliver state via body contents, query-string parameters, request headers and the requested URI (the resource name). Services deliver state to clients via body content, response codes, and response headers. This is technically referred-to as hypermedia (or hyperlinks within hypertext).\"), mdx(\"p\", null, \"Aside from the description above, HATEOS also means that, where necessary, links are contained in the returned body (or headers) to supply the URI for retrieval of the object itself or related objects. We'll talk about this in more detail later.\"), mdx(\"p\", null, \"The uniform interface that any REST services must provide is fundamental to its design.\"), mdx(\"h2\", null, \"Stateless\"), mdx(\"p\", null, \"As REST is an acronym for REpresentational State Transfer, statelessness is key. Essentially, what this means is that the necessary state to handle the request is contained within the request itself, whether as part of the URI, query-string parameters, body, or headers. The URI uniquely identifies the resource and the body contains the state (or state change) of that resource. Then after the server does it's processing, the appropriate state, or the piece(s) of state that matter, are communicated back to the client via headers, status and response body.\"), mdx(\"p\", null, \"Most of us who have been in the industry for a while are accustomed to programming within a container which provides us with the concept of \\u201Csession\\u201D which maintains state across multiple HTTP requests. In REST, the client must include all information for the server to fulfill the request, resending state as necessary if that state must span multiple requests. Statelessness enables greater scalability since the server does not have to maintain, update or communicate that session state. Additionally, load balancers don't have to worry about session affinity for stateless systems.\"), mdx(\"p\", null, \"So what's the difference between state and a resource? State, or application state, is that which the server cares about to fulfill a request\\u2014data necessary for the current session or request. A resource, or resource state, is the data that defines the resource representation\\u2014the data stored in the database, for instance. Consider application state to be data that could vary by client, and per request. Resource state, on the other hand, is constant across every client who requests it.\"), mdx(\"p\", null, \"Ever had back-button issues with a web application where it went AWOL at a certain point because it expected you to do things in a certain order? That's because it violated the statelessness principle. There are cases that don't honor the statelessness principle, such as three-legged OAuth, API call rate limiting, etc. However, make every effort to ensure that application state doesn't span multiple requests of your service(s).\"), mdx(\"h2\", null, \"Cacheable\"), mdx(\"p\", null, \"As on the World Wide Web, clients can cache responses. Responses must therefore, implicitly or explicitly, define themselves as cacheable, or not, to prevent clients reusing stale or inappropriate data in response to further requests. Well-managed caching partially or completely eliminates some client\\u2013server interactions, further improving scalability and performance.\"), mdx(\"h2\", null, \"Client-Server\"), mdx(\"p\", null, \"The uniform interface separates clients from servers. This separation of concerns means that, for example, clients are not concerned with data storage, which remains internal to each server, so that the portability of client code is improved. Servers are not concerned with the user interface or user state, so that servers can be simpler and more scalable. Servers and clients may also be replaced and developed independently, as long as the interface is not altered.\"), mdx(\"h2\", null, \"Layered System\"), mdx(\"p\", null, \"A client cannot ordinarily tell whether it is connected directly to the end server, or to an intermediary along the way. Intermediary servers may improve system scalability by enabling load-balancing and by providing shared caches. Layers may also enforce security policies.\"), mdx(\"h2\", null, \"Code on Demand (Optional)\"), mdx(\"p\", null, \"Servers are able to temporarily extend or customize the functionality of a client by transferring logic to it that it can execute. Examples of this may include compiled components such as Java applets and client-side scripts such as JavaScript.\"), mdx(\"p\", null, \"Complying with these constraints, and thus conforming to the REST architectural style, will enable any kind of distributed hypermedia system to have desirable emergent properties, such as performance, scalability, simplicity, modifiability, visibility, portability and reliability.\"), mdx(\"p\", null, \"NOTE: The only optional constraint of REST architecture is code on demand. If a service violates any other constraint, it cannot strictly be referred to as RESTful.\"), mdx(\"p\", null, \"ref \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.restapitutorial.com/\"\n  }, \"restapitutorial\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/RestCheatSheet/api-cheat-sheet#api-design-cheat-sheet\"\n  }, \"API Design Cheat Sheet\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"RESTful API","date":"2021-04-08","author":"Villager Liao","keywords":["architecture","rest"]},"slug":"rest","excerpt":"Representational state transfer The REST architectural style describes six constraints. These constraints, applied to the architecture, wereâ€¦"}},"pageContext":{"id":"6cee691f-48c3-597c-bfd3-9fd7e19ce900","slug":"rest"}},"staticQueryHashes":["1059609371","2459496995"]}