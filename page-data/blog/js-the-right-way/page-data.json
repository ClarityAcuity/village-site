{"componentChunkName":"component---src-components-md-posts-layout-js","path":"/blog/js-the-right-way","result":{"data":{"mdx":{"id":"49b85e72-1a51-5aa2-a93b-459252dfc04e","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript The Right Way\",\n  \"date\": \"2021-03-18\",\n  \"author\": \"Villager Liao\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"https://jstherightway.org/\"\n  }, \"Javascript the Right Way\")), mdx(\"h2\", null, \"Must See\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=QyUFheng6J0\"\n  }, \"Arindam Paul - JavaScript VM internals, EventLoop, Async and ScopeChains\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"a = 1;\\nvar b = 2;\\n\\nfunction f(z) {\\n  b = 3;\\n  c = 4;\\n  var d = 5;\\n  e = 6;\\n\\n  function g() {\\n    var e = 0;\\n    d = 2 * d;\\n    return d;\\n  }\\n  \\n  return g; // no call operator\\n  var e;\\n}\\n\\nmyG = f(1); // return a function \\\"g\\\"\\nmyG(); // return 10;\\n\")), mdx(\"p\", null, \"Global Scope (Window)\\n| key | value         | gc |\\n| --- | ------------- | -- |\\n| b   | \", mdx(\"del\", {\n    parentName: \"p\"\n  }, \"2\"), \" 3       | o  |\\n| f   | -> lambda \\\"f\\\" | o  |\\n| a   | 1             | o  |\\n| c   | 4             | o  |\\n| myG | -> lambda \\\"g\\\" | o  |\"), mdx(\"p\", null, \"Local scope for execution of f (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[[scope]]\"), \" copy window)\\n| key          | value           | gc |\\n| ------------ | --------------- | -- |\\n| z            | 1               | o  |\\n| this         | *               | o  |\\n| <- arguments | -> pseudoArr\", \"[1]\", \" | o  |\\n| d            | \", mdx(\"del\", {\n    parentName: \"p\"\n  }, \"5\"), \" 10        | o  |\\n| e            | 6               | o  |\\n| g            | -> lambda \\\"g\\\"   | o  |\"), mdx(\"p\", null, \"Local scope for execution of g (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[[scope]]\"), \" copy f)\\n| key          | value     | gc |\\n| ------------ | --------- | -- |\\n| this         | *         | x  |\\n| <- arguments | pseudoArr | x  |\\n| e            | 0         | x  |\"), mdx(\"h2\", null, \"Good Parts\"), mdx(\"h3\", null, \"Object Oriented\"), mdx(\"p\", null, \"JavaScript has strong object-oriented programming capabilities, even though some debates have taken place due to the differences in object-oriented JavaScript compared to other languages.\"), mdx(\"h3\", null, \"Anonymous Functions\"), mdx(\"p\", null, \"Anonymous functions are functions that are dynamically declared at runtime. They\\u2019re called anonymous functions because they aren\\u2019t given a name in the same way as normal functions.\"), mdx(\"h3\", null, \"Functions as First-Class Objects\"), mdx(\"p\", null, \"Functions in JavaScript are first class objects. This means that JavaScript functions are just a special type of object that can do all the things that regular objects can do.\"), mdx(\"h3\", null, \"Loose Typing\"), mdx(\"p\", null, \"For many front-end developers, JavaScript was their first taste of a scripting and/or interpretive language. To these developers, the concept and implications of loosely typed variables may be second nature. However, the explosive growth in demand for modern web applications has resulted in a growing number of back-end developers that have had to dip their feet into the pool of client-side technologies. Many of these developers are coming from a background of strongly typed languages, such as C# or Java, and are unfamiliar with both the freedom and the potential pitfalls involved in working with loosely typed variables.\"), mdx(\"p\", null, \"primitives\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"number\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"string\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"boolean\")), mdx(\"p\", null, \"types of objects\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"function\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"array\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"date\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"regexp\")), mdx(\"p\", null, \"special cases\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"null\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"undefined\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"7 + 7 + 7; // 21\\n7 + 7 + \\\"7\\\"; // 147\\n\\\"7\\\" + 7 + 7; // 777\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"1 == true; // true\\n1 === true; // false\\n\\n7 == \\\"7\\\"; // true\\n7 === \\\"7\\\"; // false\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"true == !\\\"0\\\"; // false\\ntrue == !!\\\"0\\\"; // true\\n\")), mdx(\"h3\", null, \"Scoping and Hoisting\"), mdx(\"p\", null, \"Scoping: In JavaScript, functions are our de facto scope delimiters for declaring vars, which means that usual blocks from loops and conditionals (such as if, for, while, switch and try) DON'T delimit scope, unlike most other languages. Therefore, those blocks will share the same scope as the function which contains them. This way, it might be dangerous to declare vars inside blocks as it would seem the var belongs to that block only.\"), mdx(\"p\", null, \"Hoisting: On runtime, all var and function declarations are moved to the beginning of each function (its scope) - this is known as Hoisting. Having said so, it is a good practice to declare all the vars altogether on the first line, in order to avoid false expectations with a var that got declared late but happened to hold a value before - this is a common problem for programmers coming from languages with block scope.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var foo = 1;\\nfunction bar() {\\n  if (!foo) {\\n    var foo = 10;\\n  }\\n  alert(foo);\\n}\\nbar(); // 10\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var a = 1;\\nfunction b() {\\n  a = 10;\\n  return;\\n  function a() {}\\n}\\nb();\\nalert(a); // 1\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// create temporary scopes within a function\\nfunction foo() {\\n  var x = 1;\\n  if (x) {\\n    (function () {\\n      var x = 2;\\n      // some other code\\n    }());\\n  }\\n  // x is still 1.\\n}\\n\")), mdx(\"p\", null, \"Declarations, Names, and Hoisting\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Language-defined: All scopes are, by default, given the names this and arguments.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Formal parameters: Functions can have named formal parameters, which are scoped to the body of that function.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Function declarations: These are of the form function foo() {}.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Variable declarations: These take the form var foo;.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function foo() {\\n  bar();\\n  var x = 1;\\n}\\n// is actually interpreted like this:\\nfunction foo() {\\n  var x;\\n  bar();\\n  x = 1;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// Notice that the assignment portion of the declarations were not hoisted. Only the name is hoisted.\\nfunction test() {\\n  foo(); // TypeError \\\"foo is not a function\\\"\\n  bar(); // \\\"this will run!\\\"\\n  var foo = function () { // function expression assigned to local variable 'foo'\\n    alert(\\\"this won't run!\\\");\\n  }\\n  function bar() { // function declaration, given the name 'bar'\\n    alert(\\\"this will run!\\\");\\n  }\\n}\\ntest();\\n\")), mdx(\"p\", null, \"Name Resolution Order\"), mdx(\"p\", null, \"The most important special case to keep in mind is name resolution order. Remember that there are four ways for names to enter a given scope. The order I listed them above is the order they are resolved in. In general, if a name has already been defined, it is never overridden by another property of the same name. This means that a function declaration takes priority over a variable declaration. This does not mean that an assignment to that name will not work, just that the declaration portion will be ignored. There are a few exceptions:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The built-in name arguments behaves oddly. It seems to be declared following the formal parameters, but before function declarations. This means that a formal parameter with the name arguments will take precedence over the built-in, even if it is undefined. This is a bad feature. Don\\u2019t use the name arguments as a formal parameter.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Trying to use the name this as an identifier anywhere will cause a SyntaxError. This is a good feature.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If multiple formal parameters have the same name, the one occurring latest in the list will take precedence, even if it is undefined.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// Named Function Expressions\\nfoo(); // TypeError \\\"foo is not a function\\\"\\nbar(); // valid\\nbaz(); // TypeError \\\"baz is not a function\\\"\\nspam(); // ReferenceError \\\"spam is not defined\\\"\\n\\nvar foo = function () {}; // anonymous function expression ('foo' gets hoisted)\\nfunction bar() {}; // function declaration ('bar' and the function body get hoisted)\\nvar baz = function spam() {}; // named function expression (only 'baz' gets hoisted)\\n\\nfoo(); // valid\\nbar(); // valid\\nbaz(); // valid\\nspam(); // ReferenceError \\\"spam is not defined\\\"\\n\")), mdx(\"p\", null, \"What the Standard Says\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"If the variable statement occurs inside a FunctionDeclaration, the variables are defined with function-local scope in that function, as described in section 10.1.3. Otherwise, they are defined with global scope (that is, they are created as members of the global object, as described in section 10.1.3) using property attributes { DontDelete }. Variables are created when the execution scope is entered. A Block does not define a new execution scope. Only Program and FunctionDeclaration produce a new scope. Variables are initialised to undefined when created. A variable with an Initialiser is assigned the value of its AssignmentExpression when the VariableStatement is executed, not when the variable is created.\")), mdx(\"h2\", null, \"Function Binding\"), mdx(\"p\", null, \"Function binding is most probably the least of your concerns when beginning with JavaScript, but when you realize that you need a solution to the problem of how to keep the context of this within another function, then you might realize that what you actually need is Function.prototype.bind().\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var myObj = {\\n    specialFunction: function () {},\\n    anotherSpecialFunction: function () {},\\n    getAsyncData: function (cb) {\\n        cb();\\n    },\\n    render: function () {\\n        var that = this;\\n        this.getAsyncData(function () {\\n            that.specialFunction();\\n            that.anotherSpecialFunction();\\n        });\\n    }\\n};\\n\\nmyObj.render();\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"this.specialFunction()\\n\\nUncaught TypeError: Object [object global] has no method 'specialFunction'\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// Function.prototype.bind() might look like\\nFunction.prototype.bind = function (scope) {\\n    var fn = this;\\n    return function () {\\n        return fn.apply(scope);\\n    };\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var foo = {\\n    x: 3\\n}\\nvar bar = function(){\\n    console.log(this.x);\\n}\\n\\nbar(); // undefined\\nvar boundFunc = bar.bind(foo);\\nboundFunc(); // 3\\n\")), mdx(\"h2\", null, \"Closure Function\"), mdx(\"p\", null, \"Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure 'remembers' the environment in which it was created in. It is an important concept to understand as it can be useful during development, like emulating private methods. It can also help to learn how to avoid common mistakes, like creating closures in loops.\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\"\n  }, \"MDN - Closures\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Closure is an implicit, permanent link between a function and it's scope chain\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Anytime you execute a funtion, it runs with a scope chain based on where it was defined (not where it is run)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The function's hidden \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[[scope]]\"), \" refernece\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"holds the scope chain (preventing garbage collection)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"is copied as the new scope's \\\"outer environment reference\\\", anytime the function is run, recreating the original chain\")))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// implicit closure\\nvar data = \\\"My Data!\\\"\\nsetTimeout(function() {\\n  console.log(data);\\n}, 3000)\\n\\n// explicit closure\\nfunction makeAdder(n) {\\n  var inc = n;\\n  var sum = 0;\\n  return function add() {\\n    sum = sum + inc;\\n    return sum;\\n  };\\n}\\n\\nvar adder3 = makeAdder(3)\\n\")), mdx(\"h2\", null, \"Strict Mode\"), mdx(\"p\", null, \"ECMAScript 5's strict mode is a way to opt in to a restricted variant of JavaScript. Strict mode isn't just a subset: it intentionally has different semantics from normal code. Browsers not supporting strict mode will run strict mode code with different behavior from browsers that do, so don't rely on strict mode without feature-testing for support for the relevant aspects of strict mode. Strict mode code and non-strict mode code can coexist, so scripts can opt into strict mode incrementally.\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\"\n  }, \"MDN - Strict mode\")), mdx(\"h2\", null, \"Immediately-Invoked Function Expression (Iife)\"), mdx(\"p\", null, \"An immediately-invoked function expression is a pattern which produces a lexical scope using JavaScript's function scoping. Immediately-invoked function expressions can be used to avoid variable hoisting from within blocks, protect against polluting the global environment and simultaneously allow public access to methods while retaining privacy for variables defined within the function.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"This pattern has been referred to as a self-executing anonymous function, but @cowboy (\", mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"http://benalman.com/news/2010/11/immediately-invoked-function-expression/\"\n  }, \"Ben Alman\"), \") introduced the term IIFE as a more semantically accurate term for the pattern.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// Either of the following two patterns can be used to immediately invoke\\n// a function expression, utilizing the function's execution context to\\n// create \\\"privacy.\\\"\\n(function(){ /* code */ }()); // Crockford recommends this one\\n(function(){ /* code */ })(); // But this one works just as well\\n\\n// Because the point of the parens or coercing operators is to disambiguate\\n// between function expressions and function declarations, they can be\\n// omitted when the parser already expects an expression\\nvar i = function(){ return 10; }();\\ntrue && function(){ /* code */ }();\\n0, function(){ /* code */ }();\\n\\n// If you don't care about the return value, or the possibility of making\\n// your code slightly harder to read, you can save a byte by just prefixing\\n// the function with a unary operator.\\n!function(){ /* code */ }();\\n~function(){ /* code */ }();\\n-function(){ /* code */ }();\\n+function(){ /* code */ }();\\n\\n// Here's another variation, from @kuvos - I'm not sure of the performance\\n// implications, if any, of using the `new` keyword, but it works.\\n// http://twitter.com/kuvos/status/18209252090847232\\nnew function(){ /* code */ }\\nnew function(){ /* code */ }() // Only need parens if passing arguments\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// This doesn't work like you might think, because the value of `i` never\\n// gets locked in. Instead, every link, when clicked (well after the loop\\n// has finished executing), alerts the total number of elements, because\\n// that's what the value of `i` actually is at that point.\\nvar elems = document.getElementsByTagName( 'a' );\\nfor ( var i = 0; i < elems.length; i++ ) {\\n  elems[ i ].addEventListener( 'click', function(e){\\n    e.preventDefault();\\n    alert( 'I am link #' + i );\\n  }, 'false' );\\n}\\n\\n// This works, because inside the IIFE, the value of `i` is locked in as\\n// `lockedInIndex`. After the loop has finished executing, even though the\\n// value of `i` is the total number of elements, inside the IIFE the value\\n// of `lockedInIndex` is whatever the value passed into it (`i`) was when\\n// the function expression was invoked, so when a link is clicked, the\\n// correct value is alerted.\\nvar elems = document.getElementsByTagName( 'a' );\\nfor ( var i = 0; i < elems.length; i++ ) {\\n  (function( lockedInIndex ){\\n    elems[ i ].addEventListener( 'click', function(e){\\n      e.preventDefault();\\n      alert( 'I am link #' + lockedInIndex );\\n    }, 'false' );\\n  })( i );\\n}\\n\\n// You could also use an IIFE like this, encompassing (and returning) only\\n// the click handler function, and not the entire `addEventListener`\\n// assignment. Either way, while both examples lock in the value using an\\n// IIFE, I find the previous example to be more readable.\\nvar elems = document.getElementsByTagName( 'a' );\\nfor ( var i = 0; i < elems.length; i++ ) {\\n  elems[ i ].addEventListener( 'click', (function( lockedInIndex ){\\n    return function(e){\\n      e.preventDefault();\\n      alert( 'I am link #' + lockedInIndex );\\n    };\\n  })( i ), 'false' );\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// This is a self-executing function. It's a function that executes (or\\n// invokes) itself, recursively:\\nfunction foo() { foo(); }\\n\\n// This is a self-executing anonymous function. Because it has no\\n// identifier, it must use the  the `arguments.callee` property (which\\n// specifies the currently executing function) to execute itself.\\nvar foo = function() { arguments.callee(); };\\n\\n// This *might* be a self-executing anonymous function, but only while the\\n// `foo` identifier actually references it. If you were to change `foo` to\\n// something else, you'd have a \\\"used-to-self-execute\\\" anonymous function.\\nvar foo = function() { foo(); };\\n\\n// Some people call this a \\\"self-executing anonymous function\\\" even though\\n// it's not self-executing, because it doesn't invoke itself. It is\\n// immediately invoked, however.\\n(function(){ /* code */ }());\\n\\n// Adding an identifier to a function expression (thus creating a named\\n// function expression) can be extremely helpful when debugging. Once named,\\n// however, the function is no longer anonymous.\\n(function foo(){ /* code */ }());\\n\\n// IIFEs can also be self-executing, although this is, perhaps, not the most\\n// useful pattern.\\n(function(){ arguments.callee(); }());\\n(function foo(){ foo(); }());\\n\\n// One last thing to note: this will cause an error in BlackBerry 5, because\\n// inside a named function expression, that name is undefined. Awesome, huh?\\n(function foo(){ foo(); }());\\n\")), mdx(\"p\", null, \"The Module Pattern\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// Create an anonymous function expression that gets invoked immediately,\\n// and assign its *return value* to a variable. This approach \\\"cuts out the\\n// middleman\\\" of the named `makeWhatever` function reference.\\nvar counter = (function(){\\n  var i = 0;\\n\\n  return {\\n    get: function(){\\n      return i;\\n    },\\n    set: function( val ){\\n      i = val;\\n    },\\n    increment: function() {\\n      return ++i;\\n    }\\n  };\\n}());\\n\\n// `counter` is an object with properties, which in this case happen to be\\n// methods.\\ncounter.get(); // 0\\ncounter.set( 3 );\\ncounter.increment(); // 4\\ncounter.increment(); // 5\\n\\ncounter.i; // undefined (`i` is not a property of the returned object)\\ni; // ReferenceError: i is not defined (it only exists inside the closure)\\n\")), mdx(\"h2\", null, \"Patterns\"), mdx(\"p\", null, \"While JavaScript contains design patterns that are exclusive to the language, many classical design patterns can also be implemented.\"), mdx(\"p\", null, \"A good way to learn about these is Addy Osmani\\u2019s open source book \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://addyosmani.com/resources/essentialjsdesignpatterns/book/\"\n  }, \"Learning JavaScript Design Patterns\"), \", and the links below are (in the majority) based on it.\"), mdx(\"h3\", null, \"What Is a Pattern?\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Patterns are proven solutions\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Patterns can be easily reused\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Patterns can be expressive\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Reusing patterns assists in preventing minor issues that can cause major problems in the application development process.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Patterns can provide generalized solutions which are documented in a fashion that doesn't require them to be tied to a specific problem.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Certain patterns can actually decrease the overall file-size footprint of our code by avoiding repetition.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Patterns add to a developer's vocabulary, which makes communication faster.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Patterns that are frequently used can be improved over time by harnessing the collective experiences other developers using those patterns contribute back to the design pattern community.\")), mdx(\"h3\", null, \"The Structure of a Design Pattern\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"context\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A system of \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"forces\"), \" that arises in that context and\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"configuration\"), \" that allows these forces to resolve themselves in context\")), mdx(\"p\", null, \"With this in mind, let\\u2019s now take a look at a summary of the component elements for a design pattern. A design pattern should have a:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Pattern name\"), \" and a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"description\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Context outline\"), \" \\u2013 the contexts in which the pattern is effective in responding to the users needs.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Problem statement\"), \" \\u2013 a statement of the problem being addressed so we can understand the intent of the pattern.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Solution\"), \" \\u2013 a description of how the user\\u2019s problem is being solved in an understandable list of steps and perceptions.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Design\"), \" \\u2013 a description of the pattern\\u2019s design and in particular, the user\\u2019s behavior in interacting with it\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Implementation\"), \" \\u2013 a guide to how the pattern would be implemented\\nIllustrations \\u2013 a visual representation of classes in the pattern (e.g. a diagram)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Examples\"), \" \\u2013 an implementation of the pattern in a minimal form\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Co-requisites\"), \" \\u2013 what other patterns may be needed to support use of the pattern being described?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Relations\"), \" \\u2013 what patterns does this pattern resemble? does it closely mimic any others?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Known usage\"), \" \\u2013 is the pattern being used in the wild? If so, where and how?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Discussions\"), \" \\u2013 the team or author\\u2019s thoughts on the exciting benefits of the pattern\")), mdx(\"h3\", null, \"Creational Design Patterns\"), mdx(\"p\", null, \"Creational design patterns focus on handling object creation mechanisms where objects are created in a manner suitable for the situation we're working in. The basic approach to object creation might otherwise lead to added complexity in a project whilst these patterns aim to solve this problem by controlling the creation process.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#factorypatternjavascript\"\n  }, \"Factory\"), \": This makes an instance of several derived classes based on interfaced data or events.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// Types.js - Constructors used behind the scenes\\n// A constructor for defining new cars\\nfunction Car( options ) {\\n  // some defaults\\n  this.doors = options.doors || 4;\\n  this.state = options.state || \\\"brand new\\\";\\n  this.color = options.color || \\\"silver\\\";\\n}\\n \\n// A constructor for defining new trucks\\nfunction Truck( options){\\n  this.state = options.state || \\\"used\\\";\\n  this.wheelSize = options.wheelSize || \\\"large\\\";\\n  this.color = options.color || \\\"blue\\\";\\n}\\n\\n\\n// FactoryExample.js\\n// Define a skeleton vehicle factory\\nfunction VehicleFactory() {}\\n \\n// Define the prototypes and utilities for this factory\\n \\n// Our default vehicleClass is Car\\nVehicleFactory.prototype.vehicleClass = Car;\\n \\n// Our Factory method for creating new Vehicle instances\\nVehicleFactory.prototype.createVehicle = function ( options ) {\\n  switch(options.vehicleType){\\n    case \\\"car\\\":\\n      this.vehicleClass = Car;\\n      break;\\n    case \\\"truck\\\":\\n      this.vehicleClass = Truck;\\n      break;\\n    //defaults to VehicleFactory.prototype.vehicleClass (Car)\\n  }\\n \\n  return new this.vehicleClass( options );\\n};\\n\\n// Create an instance of our factory that makes cars\\nvar carFactory = new VehicleFactory();\\nvar car = carFactory.createVehicle( {\\n            vehicleType: \\\"car\\\",\\n            color: \\\"yellow\\\",\\n            doors: 6 } );\\n\\n// Test to confirm our car was created using the vehicleClass/prototype Car\\n// Outputs: true\\nconsole.log( car instanceof Car );\\n// Outputs: Car object of color \\\"yellow\\\", doors: 6 in a \\\"brand new\\\" state\\nconsole.log( car );\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Abstract Factories\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var abstractVehicleFactory = (function () {\\n  // Storage for our vehicle types\\n  var types = {};\\n \\n  return {\\n      getVehicle: function ( type, customizations ) {\\n          var Vehicle = types[type];\\n \\n          return (Vehicle ? new Vehicle(customizations) : null);\\n      },\\n      registerVehicle: function ( type, Vehicle ) {\\n          var proto = Vehicle.prototype;\\n \\n          // only register classes that fulfill the vehicle contract\\n          if ( proto.drive && proto.breakDown ) {\\n              types[type] = Vehicle;\\n          }\\n \\n          return abstractVehicleFactory;\\n      }\\n  };\\n})();\\n\\n// Usage:\\nabstractVehicleFactory.registerVehicle( \\\"car\\\", Car );\\nabstractVehicleFactory.registerVehicle( \\\"truck\\\", Truck );\\n \\n// Instantiate a new car based on the abstract vehicle type\\nvar car = abstractVehicleFactory.getVehicle( \\\"car\\\", {\\n            color: \\\"lime green\\\",\\n            state: \\\"like new\\\" } );\\n \\n// Instantiate a new truck in a similar manner\\nvar truck = abstractVehicleFactory.getVehicle( \\\"truck\\\", {\\n            wheelSize: \\\"medium\\\",\\n            color: \\\"neon yellow\\\" } );\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#prototypepatternjavascript\"\n  }, \"Prototype\"), \": A fully initialized instance used for copying or cloning.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var vehicle = {\\n  getModel: function () {\\n    console.log( \\\"The model of this vehicle is..\\\" + this.model );\\n  }\\n};\\n\\nvar car = Object.create(vehicle, {\\n  \\\"id\\\": {\\n    value: MY_GLOBAL.nextId(),\\n    // writable:false, configurable:false by default\\n    enumerable: true\\n  },\\n  \\\"model\\\": {\\n    value: \\\"Ford\\\",\\n    enumerable: true\\n  }\\n});\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#mixinpatternjavascript\"\n  }, \"Mixin\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// Define a simple Car constructor\\nvar Car = function ( settings ) {\\n    this.model = settings.model || \\\"no model provided\\\";\\n    this.color = settings.color || \\\"no colour provided\\\";\\n};\\n\\n// Mixin\\nvar Mixin = function () {};\\n\\nMixin.prototype = {\\n    driveForward: function () {\\n        console.log( \\\"drive forward\\\" );\\n    },\\n    driveBackward: function () {\\n        console.log( \\\"drive backward\\\" );\\n    },\\n    driveSideways: function () {\\n        console.log( \\\"drive sideways\\\" );\\n    }\\n};\\n \\n// Extend an existing object with a method from another\\nfunction augment( receivingClass, givingClass ) {\\n    // only provide certain methods\\n    if ( arguments[2] ) {\\n        for ( var i = 2, len = arguments.length; i < len; i++ ) {\\n            receivingClass.prototype[arguments[i]] = givingClass.prototype[arguments[i]];\\n        }\\n    }\\n    // provide all methods\\n    else {\\n        for ( var methodName in givingClass.prototype ) {\\n            // check to make sure the receiving class doesn't\\n            // have a method of the same name as the one currently\\n            // being processed\\n            if ( !Object.hasOwnProperty.call(receivingClass.prototype, methodName) ) {\\n                receivingClass.prototype[methodName] = givingClass.prototype[methodName];\\n            }\\n\\n            // Alternatively (check prototype chain as well):\\n            // if ( !receivingClass.prototype[methodName] ) {\\n            // receivingClass.prototype[methodName] = givingClass.prototype[methodName];\\n            // }\\n        }\\n    }\\n}\\n\\n// Augment the Car constructor to include \\\"driveForward\\\" and \\\"driveBackward\\\"\\naugment( Car, Mixin, \\\"driveForward\\\", \\\"driveBackward\\\" );\\n\\n// Create a new Car\\nvar myCar = new Car({\\n    model: \\\"Ford Escort\\\",\\n    color: \\\"blue\\\"\\n});\\n\\n// Test to make sure we now have access to the methods\\nmyCar.driveForward();\\nmyCar.driveBackward();\\n// Outputs:\\n// drive forward\\n// drive backward\\n\\n// We can also augment Car to include all functions from our mixin\\n// by not explicitly listing a selection of them\\naugment( Car, Mixin );\\n\\nvar mySportsCar = new Car({\\n    model: \\\"Porsche\\\",\\n    color: \\\"red\\\"\\n});\\n\\nmySportsCar.driveSideways();\\n// Outputs:\\n// drive sideways\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript\"\n  }, \"Singleton\"), \": A class with only a single instance with global access points.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var mySingleton = (function () {\\n  // Instance stores a reference to the Singleton\\n  var instance;\\n\\n  function init() {\\n    // Singleton\\n    // Private methods and variables\\n    function privateMethod(){\\n        console.log( \\\"I am private\\\" );\\n    }\\n\\n    var privateVariable = \\\"Im also private\\\";\\n    var privateRandomNumber = Math.random();\\n\\n    return {\\n      // Public methods and variables\\n      publicMethod: function () {\\n        console.log( \\\"The public can see me!\\\" );\\n      },\\n      publicProperty: \\\"I am also public\\\",\\n      getRandomNumber: function() {\\n        return privateRandomNumber;\\n      }\\n    };\\n  };\\n\\n  return {\\n    // Get the Singleton instance if one exists\\n    // or create one if it doesn't\\n    getInstance: function () {\\n      if ( !instance ) {\\n        instance = init();\\n      }\\n\\n      return instance;\\n    }\\n  };\\n})();\\n\\n// Usage:\\nvar singleA = mySingleton.getInstance();\\nvar singleB = mySingleton.getInstance();\\nconsole.log( singleA.getRandomNumber() === singleB.getRandomNumber() ); // true\\n\\n// Note: as we are working with random numbers, there is a\\n// mathematical possibility both numbers will be the same,\\n// however unlikely. The above example should otherwise still\\n// be valid.\\n\")), mdx(\"h3\", null, \"Structural Design Patterns\"), mdx(\"p\", null, \"Structural patterns are concerned with object composition and typically identify simple ways to realize relationships between different objects. They help ensure that when one part of a system changes, the entire structure of the system doesn't need to do the same. They also assist in recasting parts of the system which don't fit a particular purpose into those that do.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#wrapperpatternjquery\"\n  }, \"Adapter\"), \": Match interfaces of different classes therefore classes can work together despite incompatible interfaces.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://www.joezimjs.com/javascript/javascript-design-patterns-bridge/\"\n  }, \"Bridge\"), \": Separates an object's interface from its implementation so the two can vary independently.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var RemoteControl = function(tv) {\\n    this.tv = tv;\\n    this.on = function() {\\n        this.tv.on();\\n    };\\n    this.off = function() {\\n        this.tv.off();\\n    };\\n    this.setChannel = function(ch) {\\n        this.tv.tuneChannel(ch);\\n    };\\n};\\n\\n/* Newer, Better Remote Control */\\nvar PowerRemote = function(tv) {\\n    this.tv = tv;\\n    this.currChannel = 0;\\n    this.setChannel = function(ch) {\\n        this.currChannel = ch;\\n        this.tv.tuneChannel(ch);\\n    };\\n    this.nextChannel = function() {\\n        this.setChannel(this.currChannel + 1);\\n    };\\n    this.prevChannel = function() {\\n        this.setChannel(this.currChannel - 1);\\n    };\\n};\\nPowerRemote.prototype = new RemoteControl();\\n\\n/** TV Interface\\n    Since there are no Interfaces in JavaScript I am just\\n    going to use comments to define what the implementors\\n    should implement\\n\\n    function on\\n    function off\\n    function tuneChannel(channel)\\n*/\\n\\n/* Sony TV */\\nvar SonyTV = function() {\\n    this.on = function() {\\n        console.log('Sony TV is on');\\n    };\\n    this.off = function() {\\n        console.log('Sony TV is off');\\n    };\\n    this.tuneChannel = function(ch) {\\n        console.log('Sony TV tuned to channel ' + ch);\\n    };\\n}\\n\\n/* Toshiba TV */\\nvar ToshibaTV = function() {\\n    this.on = function() {\\n        console.log('Welcome to Toshiba entertainment');\\n    };\\n    this.off = function() {\\n        console.log('Goodbye Toshiba user');\\n    };\\n    this.tuneChannel = function(ch) {\\n        console.log('Channel ' + ch + ' is set on your Toshiba television');\\n    };\\n}\\n\\n/* Let's see it in action */\\nvar sony = new SonyTV(),\\n    toshiba = new ToshibaTV(),\\n    std_remote = new RemoteControl(sony),\\n    pwr_remote = new PowerRemote(toshiba);\\n\\nstd_remote.on();            // prints \\\"Sony TV is on\\\"\\nstd_remote.setChannel(55);  // prints \\\"Sony TV tuned to channel 55\\\"\\nstd_remote.setChannel(20);  // prints \\\"Sony TV tuned to channel 20\\\"\\nstd_remote.off();           // prints \\\"Sony TV is off\\\"\\n\\npwr_remote.on();            // prints \\\"Welcome to Toshiba entertainment\\\"\\npwr_remote.setChannel(55);  // prints \\\"Channel 55 is set on your Toshiba television\\\"\\npwr_remote.nextChannel();   // prints \\\"Channel 56 is set on your Toshiba television\\\"\\npwr_remote.prevChannel();   // prints \\\"Channel 55 is set on your Toshiba television\\\"\\npwr_remote.off();           // prints \\\"Goodbye Toshiba user\\\"\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://www.joezimjs.com/javascript/javascript-design-patterns-composite/\"\n  }, \"Composite\"), \": A structure of simple and composite objects which makes the total object more than just the sum of its parts.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#decoratorpatternjavascript\"\n  }, \"Decorator\"), \": Dynamically add alternate processing to objects.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#facadepatternjavascript\"\n  }, \"Facade\"), \": A single class that hides the complexity of an entire subsystem.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// A Facade is then used to supply a much simpler API to accessing these methods\\nvar module = (function() {\\n    var _private = {\\n        i: 5,\\n        get: function() {\\n            console.log( \\\"current value:\\\" + this.i);\\n        },\\n        set: function( val ) {\\n            this.i = val;\\n        },\\n        run: function() {\\n            console.log( \\\"running\\\" );\\n        },\\n        jump: function(){\\n            console.log( \\\"jumping\\\" );\\n        }\\n    };\\n\\n    return {\\n        facade: function( args ) {\\n            _private.set(args.val);\\n            _private.get();\\n            if ( args.run ) {\\n                _private.run();\\n            }\\n        }\\n    };\\n}());\\n\\n// Outputs: \\\"current value: 10\\\" and \\\"running\\\"\\nmodule.facade( {run: true, val: 10} );\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#detailflyweight\"\n  }, \"Flyweight\"), \": A fine-grained instance used for efficient sharing of information that is contained elsewhere.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript\"\n  }, \"Module\"), \": In JavaScript, the Module pattern is used to further emulate the concept of classes in such a way that we're able to include both public/private methods and variables inside a single object, thus shielding particular parts from the global scope.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var myNamespace = (function (mixin) {\\n  var myPrivateVar, myPrivateMethod;\\n  // A private counter variable\\n  myPrivateVar = 0;\\n  // A private function which logs any arguments\\n  myPrivateMethod = function( foo ) {\\n      // Call mixin method\\n      mixin.method(foo)\\n      console.log( foo );\\n  };\\n\\n  return {\\n    // A public variable\\n    myPublicVar: \\\"foo\\\",\\n    // A public function utilizing privates\\n    myPublicFunction: function( bar ) {\\n      // Increment our private counter\\n      myPrivateVar++;\\n      // Call our private method using bar\\n      myPrivateMethod( bar );\\n    }\\n  };\\n})(mixin);\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepatternjavascript\"\n  }, \"Revealing Module\"), \":\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"var myRevealingModule = (function () {\\n  var privateCounter = 0;\\n\\n  function privateFunction() {\\n      privateCounter++;\\n  }\\n\\n  function publicFunction() {\\n      publicIncrement();\\n  }\\n\\n  function publicIncrement() {\\n      privateFunction();\\n  }\\n\\n  function publicGetCount(){\\n    return privateCounter;\\n  }\\n\\n  // Reveal public pointers to\\n  // private functions and properties\\n  return {\\n      start: publicFunction,\\n      increment: publicIncrement,\\n      count: publicGetCount\\n  };\\n})();\\n\\nmyRevealingModule.start();\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://www.joezimjs.com/javascript/javascript-design-patterns-proxy/\"\n  }, \"Proxy\"), \": A place holder object representing the true object.\")), mdx(\"h3\", null, \"Behavioral Design Patterns\"), mdx(\"p\", null, \"Behavioral patterns focus on improving or streamlining the communication between disparate objects in a system.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.joezimjs.com/javascript/javascript-design-patterns-chain-of-responsibility/\"\n  }, \"Chain of Responsibility\"), \": A way of passing a request between a chain of objects to find the object that can handle the request.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#commandpatternjavascript\"\n  }, \"Command\"), \": Encapsulate a command request as an object to enable, logging and/or queuing of requests, and provides error-handling for unhandled requests.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#mediatorpatternjavascript\"\n  }, \"Mediator\"), \": Defines simplified communication between classes to prevent a group of classes from referring explicitly to each other.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript\"\n  }, \"Observer\"), \": A way of notifying change to a number of classes to ensure consistency between the classes.\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Subject\"), \": maintains a list of observers, facilitates adding or removing observers\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Observer\"), \": provides an update interface for objects that need to be notified of a Subject's changes of state\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ConcreteSubject\"), \": broadcasts notifications to observers on changes of state, stores the state of ConcreteObservers\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ConcreteObserver\"), \": stores a reference to the ConcreteSubject, implements an update interface for the Observer to ensure state is consistent with the Subject's\")))), mdx(\"h3\", null, \"Mv* Patterns\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#detailmvc\"\n  }, \"MVC Pattern\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#detailmvp\"\n  }, \"MVP Pattern\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#detailmvvm\"\n  }, \"MVVM Pattern\"))), mdx(\"h2\", null, \"Books\"), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://jsbooks.revolunet.com/\"\n  }, \"Js Books\")), mdx(\"h2\", null, \"Reference\"), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/Tutorials\"\n  }, \"Mdn\")), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://shichuan.github.io/javascript-patterns/\"\n  }, \"Javascript Patterns\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"JavaScript The Right Way","date":"2021-03-18","author":"Villager Liao","keywords":null},"slug":"js-the-right-way","excerpt":"JavaScript The Right Way Must See Arindam Paul - JavaScript VM internals, EventLoop, Async and ScopeChains Global Scope (Window)\n| keyâ€¦"}},"pageContext":{"id":"49b85e72-1a51-5aa2-a93b-459252dfc04e","slug":"js-the-right-way"}},"staticQueryHashes":["1059609371","2459496995"]}